import hashlib
import re
import plyara
import binascii

# Florian Roth, Christian Burkard
# Version 3.0
# January 2023
#
# Known issues: fails in some cases in which 'private' rules are used

def calculate_rule_hash(rule):
    """
    Calculates a hash over the relevant YARA rule content (string contents, sorted condition)
    Requires a YARA rule object as generated by 'plyara': https://github.com/plyara/plyara
    :param rule: yara rule object
    :return hash: generated hash
    """
    hash_strings = []
    m = hashlib.md5()

    # Adding all string contents to the list
    if 'strings' in rule:

        # Loop over strings
        for s in rule['strings']:

            # String to work with 
            string_value = s['value']
            # List of modifiers
            modifiers = []

            # Byte chains
            if s['type'] == "byte":
                hash_strings.append(re.sub(r'[^a-fA-F\?0-9]+', '', string_value))

            # Others: strings, regex
            else: 
                # If modifiers exist, just use them
                if 'modifiers' in s:
                    modifiers = s['modifiers']
                # One exception: if no 'wide' modifier is set, add an 'ascii' modifier
                if not 'wide' in modifiers and not 'ascii' in modifiers:
                    modifiers.append('ascii')
                # If nocase in list, lowercase the string
                if 'nocase' in modifiers:
                    string_value = string_value.lower()
                # Sort all modifiers
                modifiers = sorted(modifiers)
                # Now add it to the string to hash
                hash_strings.append("{0}|{1}".format(string_value, ":".join(modifiers)))

    # Adding the components of the condition to the list (except the variables)
    for e in rule['condition_terms']:
        if not e.startswith("$") and not e.startswith("#"):
            hash_strings.append(e)

    # Empty
    if len(hash_strings) == 0:
        return ""

    # Generate a hash from the sorted contents
    hash_strings.sort()
    #print(hash_strings)
    m.update("".join(hash_strings).encode("ascii"))
    return m.hexdigest()


def calculate_uint_replacement(value, value_type, position):
    """
    Calculate a unit alternative for a 'string at position' expression 
    """
    value_len = len(value)
    uint_string = "(couldn't transform)"
    # Transform position to int
    pos_int = 0
    if position.startswith("0x"):
        pos_int = int(position,16)
    else:
        try:
            pos_int = int(position)
        except Exception as e:
            return uint_string

    # Transform the values
    if value_len == 1:
        hex_string = binascii.hexlify(value.encode('utf-8')).decode('utf-8')
        uint_string = "uint8(%d) == 0x%s" % (pos_int, hex_string)
    elif value_len == 2:
        hex_string = binascii.hexlify(value.encode('utf-8')).decode('utf-8')
        uint_string = "uint16be(%d) == 0x%s" % (pos_int, hex_string)
    elif value_len == 3:
        hex_string = binascii.hexlify(value.encode('utf-8')).decode('utf-8')
        uint_string = "uint16be(%d) == 0x%s and uint8(%d) == 0x%s" % (pos_int, hex_string[:4], pos_int+2, hex_string[2:])
    elif value_len == 4:
        hex_string = binascii.hexlify(value.encode('utf-8')).decode('utf-8')
        uint_string = "uint16be(%d) == 0x%s and uint16be(%d) == 0x%s" % (pos_int, hex_string[:4], pos_int+2, hex_string[4:])
    return uint_string
